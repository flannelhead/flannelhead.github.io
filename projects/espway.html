<!DOCTYPE html>

<html>
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>flannelhead's lab - ESPway</title>

        <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400italic,700|Source+Code+Pro" rel="stylesheet" type="text/css" />

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <h1 id="logo">
            <a href="../">flannelhead's lab</a>
        </h1>

        <div id="navigation">
            <a href="../">Home</a>
            <a href="../projects.html">Projects</a>
            <a href="../about.html">About</a>
        </div>

        <div id="content">
            <h1>ESPway<span class="normalweight">&nbsp;&nbsp;|&nbsp;&nbsp;A Segway-style WiFi controlled robot built on ESP8266</span></h1>

<p>Ever since I started tinkering with Arduino and embedded systems, I’ve been pretty excited about building a self-balancing, Segway-like robot. There’s a wealth of similar projects and resources around the Internet.</p>
<p>The <a href="http://sakarik.kapsi.fi/balancer/">first prototype</a> was built inside a plastic lunch box. It used an Arduino Nano and infrared remote control. It used the <a href="https://www.invensense.com/products/motion-tracking/6-axis/mpu-6050/">MPU6050</a> inertial measurement unit for detecting the orientation of the robot. The balancing worked very well, but the infrared remote control was quite impractical and unreliable.</p>
<p>The project was revived when I learned about <a href="https://en.wikipedia.org/wiki/ESP8266">ESP8266</a>, a cheap, WiFi enabled microcontroller with a pretty powerful core. Having some background in web development, the WiFi connectivity looked like a world of possibilities to me.</p>
<p>Traditionally in the Arduino community, remote controlled robots have been implemented using Bluetooth for the communication. However, this practically means that the controller software has to be implemented separately on each platform (Android, iOS, PC, etc.)</p>
<p>Web applications implemented with HTML and JavaScript are becoming more and more popular. One of the reasons is the portability. When the web app has been written once, it can be run on any platform which has a good enough web browser.</p>
<p>The ESP8266 can be configured as a WiFi access point. One can set up a HTTP server serving static pages, making the ESP8266 able to serve web apps. Now imagine if the robot control software was implemented as a web application! That is the key idea behind my project ESPway.</p>
<video controls>
<source src="../images/espway.webm" type="video/webm">
<source src="../images/espway.mp4" type="video/mp4">
<p>
Your browser doesn’t support HTML5 video. <a href="https://www.youtube.com/watch?v=R8pQ2Tb4RAg">Watch this video on YouTube.</a>
</p>
</video>
<p>The code and schematics for this little robot can be found <a href="https://github.com/flannelhead/espway">on GitHub</a>. There are preliminary instructions on building, developing and using the software. I’m also building some kind of a user manual there. The project was also <a href="https://www.reddit.com/r/esp8266/comments/5pqri1/espway_a_selfbalancing_robot_powered_by_esp8266">discussed on Reddit</a> a while ago when I posted the video.</p>
<h3 id="safety-first">Safety first</h3>
<p>Before diving deeper in the technical details, I though I should warn you about safety in case you are going to build this yourself.</p>
<p>The electronics and software don’t contain any safety features (except low voltage cutoff) as of writing this. If the firmware on the ESP8266 crashes / stalls (it can and probably <em>will</em> happen), there’s nothing stopping the motors from spinning. This is not a particular issue in my case where the robot is small and light enough to not damage its surroundings. However, please consider the safety before building a larger / heavier version of this robot. One could probably implement some failsafe system which would shut off the motors in case of a software failure.</p>
<h3 id="electronics-and-mechanics">Electronics and mechanics</h3>
<p>Most of the parts for this robot are sources from eBay / AliExpress. The <a href="https://github.com/flannelhead/espway/raw/master/schematic/espway.pdf">complete schematic</a> can be found on GitHub. One of the goals of this project was to keep the electronics as simple and cheap as possible.</p>
<p>At the core of the robot there is the ESP8266 microcontroller. It is not used as a standalone component but there’s a <a href="https://www.wemos.cc/product/d1-mini.html">WEMOS D1 mini</a> board. It has a USB connector and a USB-to-UART converter for uploading the firmware.</p>
<p>The MPU6050 is used as the orientation sensor. It communicates via I2C, and there’s a plenty of affordable breakout boards available. I used one called GY-521.</p>
<p>The motors are plain old DC motors with an integrated metal gearbox. The nominal revolution rate is 300 rpm, and they are rated for 6V. One can find these motors by searching for “n20 300rpm” or “12ga 300rpm”.</p>
<p>The motors are driven by the <a href="http://www.ti.com/lit/ds/symlink/l293d.pdf">L293D</a> dual H-bridge motor driver IC. This IC was chosen mostly because that’s what I had at hand when building the robot. Now I’ve learned that the bipolar transistor outputs produce a significant voltage drop across the bridge. Eventually I’ll replace the driver with a <a href="http://www.ti.com/lit/ds/symlink/drv8833.pdf">DRV8833</a> which has MOSFET outputs.</p>
<p>I’m using a 2-cell LiPo battery for powering the robot. It gives ~8.4 volts when fully charged. The battery voltage is monitored via the analog input of the ESP8266, and there’s an optional feature to cut off the motors when the battery voltage falls under a certain threshold. That’s common practice used with LiPo batteries. The analog input range is 0-1 volts. On the D1 mini board, there already is a voltage divider with a ratio of 1:3.3. Hence I only had to add one resistor to modify the ratio to 1:10, which scales the battery voltage to fit the analog input range.</p>
<p>Finally, two WS2812B NeoPixels are added as the “eyes” of the robot. They have proven quite useful for reporting the current state of the robot (if it has fallen, if there’s OTA update in progress etc.)</p>
<p>There’s not much to say about the mechanics, other that that optimization of size and weight were set as design goals. The prototype body was built out of some pieces of 4mm plywood and glued together with epoxy.</p>
<div class="figure">
<img src="../images/espway-portrait.jpg" alt="A general view of the robot" />
<p class="caption">A general view of the robot</p>
</div>
<h3 id="software-platform">Software platform</h3>
<p>Nowadays there is a wealth of resources and support for developing software on the ESP8266. There are two SDKs offered by the manufacturer Espressif, one with a RTOS and the other one with no operating system. There is also an <a href="https://github.com/esp8266/arduino">Arduino core</a>, the <a href="http://simba-os.readthedocs.io/en/latest/">Simba</a> cross-platform RTOS framework and <a href="http://micropython.org/">MicroPython</a>. New languages and frameworks seem to pop out every now and then, which is great!</p>
<p>Some prototyping for this robot was done on the Arduino core, using <a href="http://platformio.org/">PlatformIO</a> as the build system. The prototyping work can be found in the <a href="https://github.com/flannelhead/espway/tree/pio">corresponding branch</a> of the GitHub repo.</p>
<p>However, for maximum flexibility and control, I switched to the manufacturer’s “non-OS” SDK. That is about as native as one can get with this microcontroller. I was pleased to find there were some great libraries available for this SDK, particularly <a href="https://github.com/Spritetm/libesphttpd">libesphttpd</a> which implements a simple HTTP server and a filesystem. It was a great fit for this project as it also features WebSocket communication facilities.</p>
<h3 id="mobile-web-ui">Mobile web UI</h3>
<p>After powering on the robot and connecting a client device to the WiFi access point, one can open the user interface with a web browser at the default IP address <code>192.168.4.1</code>.</p>
<p>I tried to keep the UI as simple as possible. It essentially consists of a virtual “joystick” drawn on a HTML5 canvas. On a touch device such as a mobile phone, it feels quite intuitive.</p>
<div class="figure">
<img src="../images/espway-steering.png" alt="The user interface used for steering." />
<p class="caption">The user interface used for steering.</p>
</div>
<p>There is also a UI for on-line tuning of the robot’s PID parameters at the url <code>/pid</code>. It is a work in progress, but it’s already in a semi-usable state. It essentially allows tuning the robot in one pass without re-flashing the firmware every time the parameters are changed. One can save the tuned parameters to the flash memory via the UI.</p>
<div class="figure">
<img src="../images/espway-pid-tuning.png" alt="The initial PID tuning user interface." />
<p class="caption">The initial PID tuning user interface.</p>
</div>
<h3 id="low-latency-communications-via-a-websocket">Low latency communications via a WebSocket</h3>
<p>Probably the most interesting part of this project is the method of achieving low latency remote control.</p>
<p>Traditionally people have been implementing some kind of HTTP APIs on the ESP8266. It means that there’s a separate URL for each command. E.g. for a robot car, there would be URLs like <code>/forward</code>, <code>/backward</code>, <code>/stop</code>, <code>/turn-left</code>, <code>/turn-right</code> etc. The client application would then make <a href="https://en.wikipedia.org/wiki/Ajax_%28programming%29">AJAX</a> requests to control the robot. However, that means there would be a TCP connection opened and a HTTP header parsed on every command. That introduces unnecessary overhead and latency. The control would not be very smooth that way.</p>
<p>A better alternative is to keep the TCP socket open and send information over it in two directions. While the ESP8266 has first-class support for raw TCP communication, in JavaScript one can’t open raw TCP sockets. Instead there are <a href="https://en.wikipedia.org/wiki/WebSocket">WebSockets</a> which are TCP sockets added with a defined handshaking protocol and a data frame format. Because <code>libesphttpd</code> has a WebSocket implementation, I didn’t have to care about these details but just exchange data packets.</p>
<p>There’s a very simple protocol in the communication between the robot and the UI: the first byte of a data packet indicates which command is in question, and the subsequent bytes are additional data. The length of the additional data is known and fixed for each command. For example, a “steering” data packet sent by the client consists of three bytes: the first byte is zero (that’s defined in the code as <code>STEERING</code>). The second byte indicates the desired speed and the third one indicates turning rate (negative = left, positive = right). In this case the second and third byte are interpreted as 8-bit signed integers. The interpretation of the data bytes depends on the command in question.</p>
<p>Given smooth two-way communication, one can implement all kinds of cool things. For example, the robot can send the current battery reading to all connected clients, allowing battery monitoring in the client web app. Also, one of the most practical things is on-line tuning of the PID controller parameters.</p>
<p>In the C code, manipulation and reinterpretation of the data bytes is natural. In JavaScript, binary data is represented as an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a> which is essentially a representation of a block of raw binary data. To access and modify it, one can use a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView"><code>DataView</code></a>, which gives byte level access to the underlying binary buffer. One can e.g. say “write 13 as a 16-bit unsigned integer (little Endian) at byte offset 2 from the beginning of the buffer”. I was actually surprised to find there is such low level control available in the JavaScript APIs.</p>
<h3 id="fixed-point-sensor-fusion">Fixed-point sensor fusion</h3>
<p>Communicating with the MPU6050 via I2C is easy. One can read the hardware registers which contain acceleration and gyro readings on three axes that are updated at 1 kHz. The process of translating these values into an orientation is called “sensor fusion”. There is a signal processing core in the sensor itself that could be used to do that, and the excellent <a href="https://github.com/jrowberg/i2cdevlib/tree/master/Arduino/MPU6050"><code>I2Cdevlib</code></a> implements that. However, that requires uploading a binary firmware blob on the sensor, which is something I did not want to do. In addition, that algorithm is only capable of 200 Hz sample rate even though the raw data is available at 1 kHz.</p>
<p>Given that the ESP8266 has a 32-bit core with 16*16 -&gt; 32 widening multiplication, I thought the sensor fusion could be implemented on that instead. There are many algorithms to choose from, most notably the <a href>complementary filter</a>, <a href="http://see-out.com/sandramau/doc/Mau05MathKalman.pdf">Kalman filter</a> and <a href="http://x-io.co.uk/open-source-imu-and-ahrs-algorithms/">Madgwick filter</a>. The latter is a state-of-the-art novel algorithm which works cleverly with the <a href="https://en.wikipedia.org/wiki/Quaternion">quaternion</a> representation of the orientation. Additionally there was some sample code available to get started with, so the Madgwick algorithm was chosen.</p>
<p>The ESP8266 misses a floating point unit, and the floating point operations must be implemented in software. That complex business has been done in the compiler support libraries, but it is quite slow. Hence, I wanted to entirely avoid the usage of floating point numbers in the algorithm. Therefore I chose to translate the sample code to the Q16.16 <a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic">fixed point number representation</a>. Fixed point means that we’re essentially working integers but the 16 least significant bytes are taken to be the fractional part.</p>
<p>One nice practical detail about the implementation: in the Madgwick algorithm, one has to normalize vectors and quaternions on some occasions. Normalization in this case means dividing by a square root. ESP8266’s core doesn’t have hardware division, so it has to be implemented in the software. The same applies for the square root. Thus it doesn’t make much sense to do both operations individually if we could avoid it somehow. On the other hand, multiplication is relatively cheap in terms of operations. Dividing by the square root is equivalent to multiplying by the reciprocal of the square root. That’s what was done here – a reciprocal square root function was implemented along the lines of <a href="http://stackoverflow.com/questions/6286450/inverse-sqrt-for-fixed-point#6286865">this StackOverflow answer</a>.</p>
<h3 id="cascade-pid-control">Cascade PID control</h3>
<p>How does the robot actually maintain the balance? So far we have a nice estimate of the orientation of the robot. It has to be somehow translated to a suitable motor output signal.</p>
<p>There are two questions to answer:</p>
<ol style="list-style-type: decimal">
<li>What should the tilt angle of the robot be in order to stay balanced?</li>
<li>What should the motor output power be to achieve the desired tilt angle?</li>
</ol>
<p>This naturally leads to a control strategy that is often implemented in self-balancing robots: a cascaded <a href="https://en.wikipedia.org/wiki/PID_controller">PID controller</a>. For an introduction on PID control, I recommend the article <a href="http://manuals.chudov.com/Servo-Tuning/PID-without-a-PhD.pdf">PID without a PhD</a> by Tim Wescott. Essentially, the first controller gets the desired velocity as an input and controls the inclination angle to achieve that velocity. The desired inclination angle is fed to a second controller which regulates the motor output power to achieve that angle.</p>
<p>Naturally, the second controller gets feedback via the MPU6050 inertial measurement unit. On the other hand, getting feedback of the current velocity is not a trivial task. One could achieve that by installing rotation encoders on the motor shafts. In order to minimize the cost and simplify the circuitry, I left that out. Instead, there’s a crude approximation used in my code: the velocity feedback is taken from the motor drive signal which is smoothed in order to cancel short-term variations. This actually works surprisingly well!</p>
<p>In addition, a simple form of <a href="https://en.wikipedia.org/wiki/Gain_scheduling">gain scheduling</a> is used in situations where the robot is about to fall. A different set of PID coefficients with higher proportional gain is loaded in order to reach stability again. You can see this in action (along with some fallovers ;) in the video below.</p>
<video controls>
<source src="../images/espway2.webm" type="video/webm">
<source src="../images/espway2.mp4" type="video/mp4">
<p>
Your browser doesn’t support HTML5 video. <a href="https://www.youtube.com/watch?v=qkeA9Qc5bp0">Watch this video on YouTube.</a>
</p>
</video>
<p>The control scheme described here is not the only way to implement self-balancing robots. See <a href="http://staff.elka.pw.edu.pl/~pwawrzyn/pub-s/1502_2wrobot.pdf">this article</a> for comparison with a control scheme based on a dynamic model of the robot.</p>
<h3 id="software-drivers">Software drivers</h3>
<p>Last but not least, let’s discuss some practicalities of programming the ESP8266.</p>
<p>One problem with this microcontroller is the lack of hardware peripherals. In particular, there are no hardware implementations of I2C or PWM on the chip. They have to be implemented in software. The problem is that the very same processor core has constantly handle the WiFi communication. So, any other software routine might get interrupted by the WiFi interrupts. That’s a bit of a problem since both I2C and PWM are critical about timing.</p>
<p>Software implementations of PWM and I2C are bundled with the Espressif SDK. However, as of writing, they are flawed in some way or just inefficient. Luckily, some smart people in the community have rolled their own drivers. I ended up using <a href="https://github.com/StefanBruens/ESP8266_new_pwm"><code>ESP8266_new_pwm</code></a> by Stefan Bruens, which uses NMI interrupts to realize a stable PWM signal with correct timing. The motors are fed with 2 kHz PWM.</p>
<p>For I2C, a fast assembly implementation called <a href="https://github.com/pasko-zh/brzo_i2c"><code>brzo_i2c</code></a> by Pascal Kurtansky was used. I had some problems with the I2C driver at first since it completely disabled interrupts during I2C transactions. That eventually led to the firmware crashing, probably due to some WiFi interrupt not being able to fire. That was easily fixed by commenting out the instruction that disabled the interrupts. That compromises the I2C timing, but in practice everything has been working very well.</p>
<h3 id="feedback">Feedback</h3>
<p>If you would like a more elaborate description of something described in this article or have found something to fix, please file an issue on this site’s <a href="https://github.com/flannelhead/flannelhead.github.io">GitHub repo</a>. You can also find contact details on <a href="../about.html">this page</a>. Any feedback is very welcome and appreciated.</p>

        </div>

        <div id="footer">
            <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a><br />Except where otherwise noted, the content is licensed under a<br /><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.<br />
            &copy; 2016 Sakari Kapanen
        </div>
        
    </body>
</html>
